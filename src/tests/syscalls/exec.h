/* exec.c */
fd_s *add_fd_s(int fd);
void close_fd_s(fd_s *fds);
fd_s *malloc_fd_s(void);
void sanity_check_fd_s(fd_s *fds);
char *create_socket_order(void);
void parse_socket_order(void);
int sput_fd(char *str, int fd);
int sget_fd(const char *str);
int get_fd(fd_s *fds);
void set_state(fd_s *fds, int state);
void set_other_state(fd_s *fds, int state);
void adv_pos(void);
void print_pos(void);
void print_order(void);
void remove_close_on_exec(void);
fd_s *create_socket(int type);
void bind_socket(fd_s *fds, int port);
void bind_socket_reverse(fd_s *fds, int port, int reverse_client_server);
void listen_socket(fd_s *fds);
fd_s *accept_socket(fd_s *fds);
fd_s *accept_socket_type_ok(fd_s *fds, is_l5_t is_l5, int ok);
fd_s *connect_socket(fd_s *fds, ci_uint16 port);
fd_s *connect_socket_type_ok(fd_s *fds, ci_uint16 port, is_l5_t is_l5, int ok);
void write_socket(fd_s *fds);
void read_socket(fd_s *fds);
void close_socket(fd_s *fds);
void close_socket_ok(fd_s *fds, int ok);
void sendto_socket(fd_s *fds);
void udp_sendto_type(fd_s *fds, ci_uint32 port, is_l5_t is_l5);
void recvfrom_socket(fd_s *fds);
void udp_recvfrom_type(fd_s *fds, is_l5_t is_l5);
void socket_pair_unix(void);
fd_s *scm_rights_pass(fork_b dofork, fd_s *fds);
fd_s *scm_rights_pass_ok(fork_b dofork, fd_s *fds, int ok);
fd_s *scm_rights_unix_client(fork_b dofork, fd_s *fds);
int scm_rights_unix_child(int fd);
void scm_rights_unix_parent(int fd, fd_s *fds);
void select_socket(fd_s *fds);
void socket_sleep_client(void);
void socket_sleep_server(void);
fd_s *open_file(const char *pathname, int flags);
void close_file(fd_s *fds);
void fork_kill_parent(void);
void fork_split_socket(void);
void check_invalid_fd(int fd);
void set_close_on_exec(fd_s *fds);
int can_connect(fd_s *fds, is_l5_t is_l5);
int sync_after_listen(fd_s *fds);
int can_accept(fd_s *fds, is_l5_t is_l5);
int can_sendto(fd_s *fds, is_l5_t is_l5);
fd_s *do_socket(int type);
void do_connect(fd_s *fds, ci_uint16 port, is_l5_t is_l5);
fd_s *do_accept(fd_s *fds, is_l5_t is_l5);
void do_bind(fd_s *fds, int port);
void do_listen(fd_s *fds);
void do_write(fd_s *fds);
void do_sendto(fd_s *fds, int port);
void do_read(fd_s *fds);
void do_recvfrom(fd_s *fds, int port);
void do_close(fd_s *fds);
fd_s *do_file_open(const char *pathname, int flags);
void do_exec(void);
void do_exec2(ci_uint32 pos);
void main_label(char *text);
void check_no_open_sockets(void);
void do_cleanup(void);
void do_gen_rand_data(fd_s *fds);
void do_sleep(int sleeptime);
void do_random_sleep(int maxtime);
void do_setup(int argc, char *argv[]);
void supervisor_add_process(int pid, int id, ci_dllist *list);
void supervisor_remove_process(int pid, int id, ci_dllist *list,int timeout);
void supervisor_process(void);
void send_msg_to_supervisor(char *op);
void do_setup_mode(mode_enum modearg);
void wait_for_client(void);
int get_next_port(void);
void check_exec_pos(void);
void print_compare(int size, char *data1, char *data2);
void create_log_file(int lid, int lpos);
int random_int(int min, int max, unsigned int *seedp);
fd_s *get_random_open_socket(ci_uint32 *ran);
void perform_random_op(fd_s *fds, rand_state_s ops[]);
int random_distrib(int x);
int main(int argc, char *argv[]);
void soak_test(void);
void strobe_exec_over(void);
static void check_timeout(int sighandler, int allowance);
void set_next_port(int id);
void print_warnings(void);
void setup_end_time(void);
void setup_timers(int clear);
void close_logfd(void);
